<meta charset="utf-8">


                            **Chapter 5: Importance Sampling Materials**

Our goal over the next two chapters is to instrument our program to send a bunch of extra rays
toward light sources so that our picture is less noisy. Let’s assume we can send a bunch of
rays toward the light source using a pdf pLight(direction)

. Let’s also assume we have a pdf
related to s,

and let’s call that pSurface(direction)

. A great thing about pdfs is that you can just
use linear mixtures of them to form mixture densities that are also pdfs. For example, the
simplest would be:
p(direction) = 0.5*pLight(direction) + 0.5*pSurface(direction)
As long as the weights are positive and add up to one, any such mixture of pdfs is a pdf. And
remember, we can use any pdf-- it doesn’t change the answer we converge to! So, the game
is to figure out how to make the pdf larger where the product s(direction)*color(direction)

is
large. For diffuse surfaces, this is mainly a matter of guessing where color(direction)

is high.
For a mirror, s()

is huge only near one direction, so it matters a lot more. Most renderers in fact
make mirrors a special case and just make the s/p implicit-- our code currently does that.
Let’s do simple refactoring and temporarily remove all materials that aren’t Lambertian. We
can use our Cornell Box scene again, and let’s generate the camera in the function that
generates the model:
At 500x500 my code produces this image in 10min on 1 core of my Macbook:
Reducing that noise is our goal. We’ll do that by constructing a pdf that sends more rays to
the light.
First, let’s instrument the code so that it explicitly samples some pdf and then normalizes for
that. Remember MC basics: integral f(x)

is approximately f(r)/p(r)

. For the Lambertian
material, let’s sample like we do now: p(direction) = cos(theta) / Pi.
We modify the base-class material

to enable this importance sampling:
And Lambertian

material becomes:
And the color function gets a minor modification.
You should get exactly the same picture.
Now, just for the experience, try a different sampling strategy. Let’s choose randomly from the
hemisphere that is above the surface. This would be p(direction) = 1/(2*Pi)

.
And again I should get the same picture except with different variance, but I don’t!
It’s pretty close to our old picture, but there are differences that are not noise. The front of the
tall box is much more uniform in color. So I have the most difficult kind of bug to find in a Monte
Carlo program-- a bug that produces a reasonable looking image. And I don’t know if the bug
is the first version of the program or the second, or even in both!
Let’s build some infrastructure to address this.



<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep.min.js"></script>
<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
